using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;
using Nemerle;
using Nemerle.Compiler;
using Nemerle.Compiler.Parsetree;

using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Threading;

namespace Nemerle.Statechart
{


  //using GuardNode;
  // TODO: Action events with flag
  /// <summary>
  /// Description of StaticGenerator.
  /// </summary>
  public partial class StaticGenerator
  {

    DefineState(ty : TypeBuilder, type : ClassMember.TypeDeclaration, st : ActiveStateConfig) : TypeBuilder
    {
      def type = DefineNested(ty, type);
      DefineTransitions(type, st); // define transitions in state
      type
    }

    DefineState(ty : TypeBuilder, st : ActiveStateConfig) : TypeBuilder
    {
      def id_type = StateIdType;
      def (expr, _) = GetId(st.Id);

      def type = <[ variant_option: |  $(st.name : usesite)
                            {
                                public override get_id() : $id_type {$expr}

                                public static Id() : $id_type
                                {
                                    $expr
                                }

                                public override ToString() : string
                                {
                                    $(st.name)
                                }
                            } 
                    ]>;

      def type = DefineState(ty, type, st);
      type
    }

    DefineStates() : void
    {
      def id_type = StateIdType;
      def default = StateIdDefaultValue;
      def top = <[decl:
                  public variant State : HsmState
                  {

                      public virtual get_id() : $id_type { $default }

                      public override ToString() : string
                      {
                        null
                      }
                  } ]>;
      def ty = DefineNested(ty, top);
      state_builder = ty;

      when (HasDeferedEvents) DeferrableEvents.EmitIsDeferDeclaration(ty);
      def defs = Events.Map(x => <[ decl: public virtual $(x.Name : usesite)(_ : $(ChartName : usesite)) : State { null } ]>);
      Define(ty, defs);
      compile_list ::= state_builder;
      foreach (st in ActiveStates)
      {
        def ty = DefineState(ty, st);
        compile_list ::= ty;
        StateBuilders ::= (st, ty);
      }
    }

    DefineEvents() : void
    {
      def evt = GenEvent(this, Events);
      evt.Generate()
    }

    DefineGuards() : void
    {
    }    

    DefineActions() : void
    {
      foreach (act in actions)
      {
        DefineActionEvent(act)
      }

      def gen_paths = GenTranPath(path_state_actions, action_for, util, FsmFlags);
      gen_paths.DefineHandlers()
    }

    DefineSubMachines() : void
    {
      def clone(f)
      {
        | ClassMember.Function(name = n) as f => ClassMember.Function(f.Location, n, f.modifiers, f.header, f.implemented, f.body)
      }

      def top = ty.Manager.Hierarchy.TopTypeBuilders();
      def this_mems = ty.AstParts.SelectMany(x => x.GetMembers()).Select(_.Name);
      foreach (st in LoadedMachines)
      {
        match (top.Find(x => x.Name == st.Key))
        {
          | Some(t) => def mems = t.GetParsedMembers();
                      foreach (m in mems)
                      {
                        when (!this_mems.Exists(x => x == m.Name))
                        {
                          def m = match (m)
                          {
                            | ClassMember.Property(name = n, modifiers = mod, parameters = pp, getter = g, setter = s, initializer = i) as p =>
                                ClassMember.Property(p.Location, n, mod, p.returnType, pp, g.Map(clone), s.Map(clone), i)
                            | _                      => m
                          }
                          ty.Define(m)
                        }
                      }
          | _       => ()
        }

      }
    }
  }
}
